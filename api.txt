
// Sending.

1. // Message based.
ws_send_msg()

2. // Frame based (One big message many frames)
ws_msg_begin()									NONE -> MSG_BEGIN
ws_msg_frame_send()								
		|____________ws_msg_frame_data_begin()	MSG_BEGIN -> IN_MSG
...					 ws_msg_frame_data_send()	IN_MSG -> IN_MSG
...					 ws_msg_frame_data_send()	IN_MSG -> IN_MSG
ws_msg_frame_send()
ws_msg_end()

3. // Stream (one huge frame)..
ws_msg_begin()
ws_msg_frame_data_begin() // Size is set here.
ws_msg_frame_data_send()
...
ws_msg_frame_data_send()


// Receiving

1. ws_on_msg(msg, is_binary)

2. ws_on_msg_begin(opcode, is_binary)
   ws_on_msg_frame(payload)
   ws_on_msg_end() ----> ws_on_msg()

3. 
   ws_on_msg_frame_begin() // If this is the first frame -> ws_on_msg_begin()
   ws_on_msg_begin()
   ws_on_msg_frame_data()
   ...
   ws_on_msg_frame_data()
   ws_on_msg_frame_end() ----> ws_on_msg_frame()
   ws_on_msg_end()


* Add a "protocol validation" error, for when the frame is somehow incorrect, or the handshake fails.

- If msg_callback set, build msg from incoming frames and call on_msg

- If msg_begin is set, turn of on_msg (but still check for ping/pong)
	(we won't start building the msg unless the user calls the default callback from its own callback) 

- msg_begin/msg_frame/msg_end can only be set together:
	
	- If the user decides to not call the default implementations
	  from his callbacks, its up to the user to assemble the message.
	
	- The default callbacks uses an evbuffer to assemble the message.

	- Should evbuffer_pullup be used to pass the payload of 
	  frames to the user?:
	  	<Received enough data for the entire frame>
	  	if (frame_callbacks_are_set)
	  		evbuffer_pullup... -> pass pointer to callback
	  		in default callback:
	  			(see below)
	  	else
	  		call default callback
	  		in default callback:
  				bypass msg_frame payload msg
  				copy directly from bufferevent in-buffer to the msg evbuffer.

  				The evbuffer_remove_buffer() function moves exactly datlen bytes from src to the end of dst, copying as little as possible. If there are fewer than datlen bytes to move, it moves all the bytes. It returns the number of bytes moved.

After connection handshake...

Read data
	
	if no header is read yet:

		- Got enough data to read header? Need more! return
		- Read header (only remove as much as needed)
			- Call handle_frame_begin
	else
			- Unmask data
			- Call handle_frame_data





handle_frame_begin















